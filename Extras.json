** ( PHP Extras ):


- - - ( ALL PHP Data Types ) - - -

* ( Scalar Types (4) ):
• bool
• int
• float
• string


* ( Compound Types (4) ):
• array
• object
• callable
• iterable


* ( Special Types ): 
• null
• "resource", a special variable type that holds a reference 
   to an external resource outside of PHP's memory




- - - ( PHP null related / handling operators ) - - -


  1)( ?? → Null coalescing operator ):

  Returns the left-hand value if it exists and is not null, 
  otherwise returns the right-hand value, e.g..

  • "$name = $_GET['name'] ?? 'Guest';"



  2)( ?-> → Nullsafe operator ):

  Safely accesses properties or methods of an object that 
  could be null, e.g..

  • "$city = $user?->profile?->address?->city;"



  3)( ??= → Null coalescing assignment operator ):

  Safely accesses properties or methods of an object that 
  could be null

  If any part of the chain is null, the whole expression returns 
  null instead of throwing an error

  • "?Type → Nullable type hint / nullable type declaration"



  4)( Nullable type ?Type ):

  Allows a property, parameter, or return value to be 
  either the specified type or null

  Useful for type safety while allowing null values

  • "public ?float $price;"
  • "function setScore(?int $score) { ... }"
  • "function findUser(int $id): ?User { ... }"




- - - ( PHP String Functions ) - - - 


1)( explode() ):

- splits a string into an array of substrings, based on a delimiter.

 
  ( Example ):

  $fruits = "apple | banana ? orange"; 
  $parts = explode(" ? ", $fruits)[0];

  print_r($parts);

  /* 
  outputs: apple | banana

  array: 
  [0] = apple | banana
  [1] =  orange
  */



2)( implode() ):

- Joins an array into a string with a separator


  ( Example ):

  $fruits = ["apple", "banana", "orange"];
  echo implode(" | ", $fruits);
  // apple | banana | orange



3)( str_split() ):

- Splits a string into an array, but by character or chunk size.


  ( Example ):

• $str = "hello";
  print_r(str_split($str));
  // ['h', 'e', 'l', 'l', 'o']


• print_r(str_split("123456", 2));
  // ['12', '34', '56']



4)( substr() ):

- Extracts part of a string by position


  ( Example ):
  
  echo substr("Hello World", 0, 5); // Hello



5) ( preg_split() ):

- Like explode(), but uses a regex pattern instead of a simple delimiter


 ( Example ):

  $str = "one, two; three|four";
  $parts = preg_split("/[;,|]\s*/", $str);
  print_r($parts);
  // ['one', 'two', 'three', 'four']




- - - ( Heredoc & Nowdoc ) - - -

- Useful for multi-line strings



* ( Example ):

$x = 1;
$y = 2;


( Heredoc ):
$text = <<MyText
Line 1 $x
Line 2 $y
Line 3 
MyText;

/* 
Outputs:
Line 1 1
Line 2 2
Line 3 
*/


( Nowdoc ):
$text = <<'MyText' //Must be Single quotes
Line 1 $x
Line 2 $y
Line 3 
MyText;

/* 
Outputs:
Line 1 $x
Line 2 $y
Line 3 
*/




- - - ( Switch vs Match ) - - - 


- functionality & concept wise. theyre the same, but
  their differences lies in comparison
• "Switch" = Loose Comparison 
• "Match" = Strict Comparison

  for "loose comparison", it sees 1 & "1" as the same, 
  while in "strict comparison", it does not


- another is that, values in switch must be constatant 
  unlike, match which allows expressions 


- Lastly, you can assign Match to a variable, in which 
  it returns the value that matches the key, while in
  Switch you can't 



* ( Switch ):

  $fruit = "apple";
  $str = "apple";

  switch ($fruit) {
      case $str:  // ❌ Not allowed: case value must be constant
          echo "It's an apple!";
          break;
      case "banana":
          echo "It's a banana!";
          break;
      default:
          echo "Unknown fruit";
  }


  ( Problems / Limitations ):

  • Case values must be constants, cannot use variables like $str.

  • Loose comparison (==) is used, so type juggling can happen.

  • Cannot directly assign switch to a variable.

  • Risk of fall-through if break is forgotten.



* ( Match ):

  $fruit = "apple";
  $str = "apple";

  $result = match($fruit) {
      $str => "It's an apple!",  // ✅ Allowed: variables or expressions
      "banana" => "It's a banana!",
      default => "Unknown fruit",
  };

  echo $result;


  ( Advantages of match: ):

  • Strict comparison (===) → no type juggling.

  • Can use variables or expressions as case values.

  • Returns a value → assign directly to a variable.

  • No fall-through → cleaner and safer.




- - - ( Include & Require ) - - -


- both functions are used to include contents of separated files 

- the difference of "Include" & "Require" is that

• If a "Included Script" contains or doesn't exist, 
  it only stops "that" included Script, then the rest
  of the Scipt where it was included goes on

• If a "Required Script" contains errors or doesn't exist, 
  it stops "that" Script, and the Script where it was Required 
  

  
* ( Require Once & Include Once ):

- The Functionality of Adding Once to both "Require & Include"
  are the same, 
  
  they prevent duplicates / 2 Same files, to be "Included" / "Required" 
  
  by Running the first "Include / Require" & "discarding" the "Repeated Call"



* ( Cascading Effect Example ):

 - hello_function.php// contains the function to say hello world 
   hello_output.php // calls the function
   index.php()// both files are included in the index.php
   "hello_output.php" can call the function, only because...

 • both files are "included" / "required" in the same file  

 • "Cascading Effect", the file that contains the function 
   that will be called by "hello_output.php", is declared first




- - - ( Namespaces ) - - -

- A function that prevents...
• functions
• classes
• constants 
  from having duplicated names of the same type

 
- also acts like a "path" / "container", that organizes 
  code into logical groups & makes it easier to "import" 
  "w/use"



* ( Sample of Duplicate Names ):

 namespace Hello1\Hello2;

 function Hello1(){...}
 function Hello1(){...}
 //functions w/same names causes Error


 class Hello2{...}
 class Hello2{...}
 //classes w/same names causes Error



* ( Sample of Creating Namespace Paths & "Using" them ):

 ( Math.php ):

 namespace MyMath\Operations;//Created Namespace #1
 
 function add(){...}//Part of Namespace #1


 namespace MyMath\Names;//Newly Created Namespace #2
 
 const PI = 3.14159;//Part of Namespace #2



 ( index.php ):

 require "Math.php";

 use MyMath\Operations\add;
 use MyMath\Names\PI;

 $a = add();
 $b = PI;


  
* ( Sample of Namespace Path w/Use ): 

 // ✅ Step 1: actually load the file
 require "Models/User.php";

 // ✅ Step 2: shorten namespace paths with `use`
 use App\Models\Class;
 use App\Models\Function;
 use App\Models\Constant;

 // ✅ Step 3: Assign
 $a = new Class();
 $b = Function();
 $c = Constant;




- - - ( declare(strict_types=1); ) - - -

- this code enforces strict typing on the Script that it was 
  declared 

- Without it, PHP uses "weak typing"( converts values automatically )

- It only affects function/method "parameters" & "return types"




- - - ( Autoloading ) - - -

- a way to use classses, w/o using "include" or "require",
  multiple times on the file path, where those classes 
  are stored 


• ( Sample of Autoloading #1, w/o namespace ): 

  spl_autoload_register(function ($class) {
    $path = __DIR__ . '/' . $class . '.php';

    if (file_exists($path)) { require $path; }
  });

  
  
• ( Sample of Autoloading #2, w/namespace ): 

  spl_autoload_register(function ($class) {
    $path = __DIR__ . '/' . str_replace('\\', '/', $class) . '.php';

    if (file_exists($path)) { require $path; }
  });



• ( Example of Autoloading #3, w/Composer & PSR-4 ):


( From composer.json ):

  "autoload": {
    "psr-4": {
      "*Namespace/Class\\": "*Directory of the Class"
    }
  }


( Composer CMD & require autoload.php ):

  CMD: composer dump-autoload
  //generate & autoload the script, which will create a vendor folder  
  //( note: CMD must be done when a new Namespace(s) is added )
  

  CODE: require "vendor/autoload.php";
  //to include the file to your script 




- - - ( Response Headers ) - - -

• header("Location: /newpage.php"); // Redirects the client to another page.

• header("Content-Type: application/json"); // Defines response format (HTML, JSON, text, etc.).

• header("HTTP/1.1 404 Not Found"); // Sends an HTTP status response.

• header("Cache-Control: no-cache"); // Prevents caching of the response.

• header("Expires: 0"); // Tells browser content is already expired (no caching)

• header("Content-Disposition: attachment; filename=file.txt"); 
  // Forces browser to download instead of display.